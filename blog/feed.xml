<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on bitcoin-dev blog</title><link>https://bitcoin-dev.blog/blog/</link><description>Recent content in Blogs on bitcoin-dev blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://bitcoin-dev.blog/blog/feed.xml" rel="self" type="application/rss+xml"/><item><title>Schnorr basics</title><link>https://bitcoin-dev.blog/blog/schnorr-basics/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://bitcoin-dev.blog/blog/schnorr-basics/</guid><description>&lt;p>If you&amp;rsquo;re having a difficult time wrapping your head around Schnorr
signatures, you&amp;rsquo;re not alone. In this post, I attempt to explain
Schnorr signatures at a level that I myself appreciate, and
hopefully, you&amp;rsquo;ll find it valuable too.&lt;/p>
&lt;h2 id="whats-schnorr">What&amp;rsquo;s Schnorr?&lt;/h2>
&lt;p>Schnorr is a new signature scheme in Bitcoin that got activated in the
taproot upgrade. Schnorr has some nice properties listed in
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#motivation">BIP340&lt;/a>, but I won&amp;rsquo;t reiterate those here.&lt;/p>
&lt;h2 id="signing-and-verifying">Signing and verifying&lt;/h2>
&lt;p>A signature scheme consists of two actions, signing and verification
as the following diagram shows.&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/schnorr-basics/sig-overview.svg" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded"
alt="Left side: signing using a message and a private key. Right side: verification that the message (the cat) was signed with the correct private key." width="80%" height="80%"/>&lt;figcaption>
&lt;p>
&lt;center>Left side: signing using a message and a private key. Right side: verification that the message (the cat) was signed with the correct private key.
&lt;/center>
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>The signer has a private key and a message to sign (for example, a
Bitcoin transaction or a cat picture) and produces a signature. The
verifier has the public key corresponding to the private key that the
signer used, the message, and the signature. The verification process
makes sure that the signature was created with the correct private
key without knowing the private key.&lt;/p>
&lt;p>If you want a more in-depth explanation, please visit &lt;a href="https://rosenbaum.se/book/grokking-bitcoin-2.html#_digital_signatures">the second half of chapter 2 of Grokking Bitcoin&lt;/a>.&lt;/p>
&lt;h3 id="signer">Signer&lt;/h3>
&lt;p>We&amp;rsquo;re now going to see how a Schnorr signature is created. It
represents the left side of the diagram above. I assume that you&amp;rsquo;re
familiar with how a key pair is created using a random number
generator and an elliptic curve. If not, I suggest you read
&lt;a href="https://rosenbaum.se/book/grokking-bitcoin-4.html#public-key-math">section 4.8 of Grokking Bitcoin&lt;/a>.&lt;/p>
&lt;p>Suppose that you want to make a signature for the cat picture. The
picture is the message, $m$, to sign. Your private key is $p$ which belongs to your public key $P$.&lt;/p>
&lt;p>The first thing you&amp;rsquo;ll do is to draw a random number, $r$, that we&amp;rsquo;ll
call the nonce (for &amp;ldquo;Number Once&amp;rdquo;). Then you&amp;rsquo;ll treat $r$ as if it was
a private key, which means that you can generate the corresponding
public key by multiplying it with $G$, which is the &lt;em>generator
point&lt;/em>. At this stage, you have the following:&lt;/p>
&lt;p>$$
\begin{align}
p &amp;amp; : \text{private key} \\&lt;br>
P = pG &amp;amp; : \text{public key} \\&lt;br>
m &amp;amp; : \text{message} \\&lt;br>
r &amp;amp; : \text{random nonce} \\&lt;br>
R = rG &amp;amp; : \text{nonce commitment}
\end{align}
$$&lt;/p>
&lt;p>$R$ is your &lt;em>nonce commitment&lt;/em> which will become the first part of
the final signature, and $r$ must remain secret
(&lt;a href="#why-r-secret">explained later&lt;/a>) and never be reused (also
&lt;a href="#nonce-reuse">explained later&lt;/a>). You&amp;rsquo;ve prepared everything you need
to make the signature. You&amp;rsquo;ll do it in two steps. Step 1 is to
calculate a so-called &lt;em>challenge hash&lt;/em>, $e$:&lt;/p>
&lt;p>$$
e = H(R || P || m)
$$&lt;/p>
&lt;p>The challenge hash is the hash of the challenge, which is the
concatenation of $R$, $P$, and $m$. These components will all be
available to the verifier. Using the challenge hash, you can now do step 2:
Calculate the &lt;em>challenge response&lt;/em>, or simply &lt;em>response&lt;/em>, $s$, which
is the second part of the signature (Thanks to Anthony Towns,
Ruben Somsen, and nothingmuch on Twitter for
&lt;a href="https://twitter.com/kallerosenbaum/status/1472515231050080266">their help with the name &lt;em>response&lt;/em>&lt;/a>.):&lt;/p>
&lt;p>$$
s = r + ep \tag{1} \label{respeqn}
$$&lt;/p>
&lt;p>Finally, your signature is&lt;/p>
&lt;p>$$
(R,s)
$$&lt;/p>
&lt;p>You send the cat picture, $m$, and your signature $(R,s)$ to your
friend, Fred.&lt;/p>
&lt;h3 id="verifier">Verifier&lt;/h3>
&lt;p>Fred wants to make sure the cat picture hasn&amp;rsquo;t been compromised during
transfer and that it really originates from you, the only one with
access to your private key $p$. He has access to $P$, $m$, $R$, and
$s$. Of course, he also has access to $G$ because that&amp;rsquo;s a widely
known constant. From this information, he can calculate the challenge
hash and verify that the &lt;em>verification equation&lt;/em> balances:&lt;/p>
&lt;p>$$
\begin{align}
e &amp;amp; = H(R || P || m) \\&lt;br>
sG &amp;amp; = R + eP \tag{2} \label{vereqn}
\end{align}
$$&lt;/p>
&lt;p>&lt;strong>If this equation balances, Fred can be sure that the signature was
made with $p$&lt;/strong>. Note that the verification equation, equation
$(\ref{vereqn})$, is the response equation, $(\ref{respeqn})$, where
both sides are multiplied by $G$. Starting with the response equation,
we get&lt;/p>
&lt;p>$$
\begin{align}
&amp;amp;s = r + ep \iff sG = (r+ep)G \\&lt;br>
&amp;amp;\iff sG = rG + epG \iff sG = R + eP
\end{align}
$$&lt;/p>
&lt;p>As you can see: If the response equation holds, the verification
equation holds. Likewise, if the verification equation holds, the
response equation also holds. Thus, when Fred verifies the equation
based on points on the elliptic curve, the verification equation, he
also implicitly verifies that the response equation, based on scalars,
holds.&lt;/p>
&lt;p>When Fred has verified the signature, he can enjoy the cat picture,
fully confident that it&amp;rsquo;s actually the same picture as you sent him.&lt;/p>
&lt;h2 id="why-is-r-secret-a-idwhy-r-secreta">Why is $r$ secret? &lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/h2>
&lt;p>You might wonder why the nonce $r$ must be kept secret. You might even
wonder why it&amp;rsquo;s needed at all? Let&amp;rsquo;s start with the latter. Let&amp;rsquo;s remove $r$ from the process and see what happens.&lt;/p>
&lt;p>You would create the signature as follows:&lt;/p>
&lt;p>$$
\begin{array}{}
e = H(P || m) \\&lt;br>
s = ep
\end{array}
$$&lt;/p>
&lt;p>The signature would consist only of $s$. Fred would then verify your signature as:&lt;/p>
&lt;p>$$
\begin{array}{}
e = H(P || m) \\&lt;br>
sG = eP
\end{array}
$$&lt;/p>
&lt;p>That equation holds, but it would also allow Fred to extract the
private key $p$ since he knows both $s$ and $e$. He&amp;rsquo;ll take the
response equation and solve it for p:&lt;/p>
&lt;p>$$
s = ep \iff p = \frac{s}{e}
$$&lt;/p>
&lt;p>OK, we need the nonce to prevent Fred from figuring out your private
key, but why must we keep the nonce secret? Why the hassle of using
the nonce commitment, instead of the nonce itself?&lt;/p>
&lt;p>It&amp;rsquo;s for the same reason. Suppose that that the nonce, $r$, was made
available to Fred, then he could figure out $p$ by:&lt;/p>
&lt;p>$$
\begin{array}{}
e = H(R || P || m) \\&lt;br>
s = r + ep \iff p = \frac{s-r}{e}
\end{array}
$$&lt;/p>
&lt;p>So Fred could calculate $p$ by subtracting $r$ from $s$ and dividing
the result by $e$.&lt;/p>
&lt;p>By revealing just the nonce commitment, $R$, to Fred, we make sure
that Fred can&amp;rsquo;t calculate $p$ while at the same time allowing him to
verify that $p$ was used to generate the signature.&lt;/p>
&lt;h2 id="dont-reuse-nonces-a-idnonce-reuse">Don&amp;rsquo;t reuse nonces &lt;!-- raw HTML omitted -->&lt;/h2>
&lt;p>Even if you keep the nonce secret, you may still leak your private key
if you use the nonce twice for the same private key. Suppose that you
make two signatures with the same nonce and private key as follows:&lt;/p>
&lt;p>$$
\begin{array}{lr}
e = H(R || P || m) &amp;amp; e' = H(R || P || m')\\&lt;br>
s = r + ep &amp;amp; s' = r + e&amp;rsquo;p
\end{array}
$$&lt;/p>
&lt;p>Then you give the signatures $(R,s)$ and $(R,s')$ to the verifier. The
verifier can then use simple arithmetic to calculate your private
key. He can set up an equation system with two equations and two
unknown as follows:&lt;/p>
&lt;p>$$
\begin{align}
s &amp;amp;= r + ep\\&lt;br>
s' &amp;amp;= r + e&amp;rsquo;p
\end{align}
$$&lt;/p>
&lt;p>This is solvable for $p$ by subtracting $s'$ from $s$:&lt;/p>
&lt;p>$$
\begin{align}
&amp;amp;s-s'=r+ep-r-e&amp;rsquo;p \\&lt;br>
&amp;amp;=(e-e')p \implies p=\frac{s-s'}{e-e'}
\end{align}
$$&lt;/p>
&lt;p>As you can see, the verifier will be able to extract the private
key. Lesson learned: Don&amp;rsquo;t reuse nonces.&lt;/p>
&lt;p>If the nonce is reused, but for different private keys, $p$ and $p'$,
the above equation system wouldn&amp;rsquo;t be solvable because you&amp;rsquo;d have
three unknowns, $p$, $p'$, and $r$, but only &lt;em>two&lt;/em> equations.&lt;/p>
&lt;h2 id="whats-with-the-challenge-a-idchallenge">What&amp;rsquo;s with the challenge? &lt;!-- raw HTML omitted -->&lt;/h2>
&lt;p>The challenge hash, $e$, is the hash of the challenge $R||P||m$. Why
do we use this particular challenge? Let&amp;rsquo;s look at the three components separately.&lt;/p>
&lt;h3 id="m">$m$&lt;/h3>
&lt;p>The message to sign is $m$, so it&amp;rsquo;s really important that $m$ is
somehow committed to by the signature. If we&amp;rsquo;d remove $m$ from the
challenge, the &amp;ldquo;signature&amp;rdquo; would be valid for any message.&lt;/p>
&lt;h3 id="r">$R$&lt;/h3>
&lt;p>(Thanks to &lt;a href="https://x0f.org/@waxwing/107491024866468566">waxwing&lt;/a> and
&lt;a href="https://mastodon.social/@ajtowns/107491605500890702">A J Towns&lt;/a> for
their help in sorting this out.)&lt;/p>
&lt;p>To make sure that no one but the owner of the private key can create a
signature, the challenge must contain the nonce commitment
$R$. Suppose that the challenge didn&amp;rsquo;t include the nonce commitment,
then a signature can be trivially forged by anyone with access to the
public key $P$. They can make up an arbitrary $s$ and do:&lt;/p>
&lt;p>$$
\begin{align}
&amp;amp;e = H(P||m)\\&lt;br>
&amp;amp;s = \text{any number} \\&lt;br>
&amp;amp;sG=R+eP \implies R=sG-eP
\end{align}
$$&lt;/p>
&lt;p>The last equation is the &amp;ldquo;verification equation&amp;rdquo;, but solved for
$R$. The right side of that equation contains only known variables,
$s$, $e$, and $P$. Thus the signature $(R,s)$ is valid.&lt;/p>
&lt;p>With $R$ in the challenge, it&amp;rsquo;s impossible to solve the
verification equation for $R$ because $R$ is part of the challenge
$e$. It&amp;rsquo;s hard to find an $R$ such that $R=sG-H(R||P||m)P$.&lt;/p>
&lt;h3 id="p">$P$&lt;/h3>
&lt;p>Let&amp;rsquo;s finally see what $P$ is doing in the challenge. Suppose that we
didn&amp;rsquo;t have $P$ in the challenge, $e=H(R||m)$, and that the signature
$(R,s)$ is valid for public key $P$ and message $m$. Then the
signature $(R,s')=(R,s+ex)$, where $x$ is an arbitrary number, would
be valid for a public key $P'=P+xG$ and message $m$. Let&amp;rsquo;s look at
why:&lt;/p>
&lt;p>$$
\begin{align}
&amp;amp;e = H(R || m) \\&lt;br>
&amp;amp;s&amp;rsquo;G=R+eP' \iff (s+ex)G=R+e(P+xG) \iff \\&lt;br>
&amp;amp;sG+exG=R+eP+exG \iff sG=R+eP+exG-exG \iff \\&lt;br>
&amp;amp;sG=R+eP
\end{align}
$$&lt;/p>
&lt;p>This is known as a related-key attack. If you&amp;rsquo;re familiar with how
extended public key derivation in
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32&lt;/a>
works, you might see the potential danger. For a refresher, here&amp;rsquo;s the
general idea:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/schnorr-basics/xpub-derivation.svg" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded"
alt="Deriving a child extended public key from a parent extended public key, The orange paper strips are known as chain code, described in detail in Grokking Bitcoin. You just need to know that they&amp;amp;rsquo;re 256-bit numbers." width="80%" height="80%"/>&lt;figcaption>
&lt;p>
&lt;center>Deriving a child extended public key from a parent extended public key, The orange paper strips are known as chain code, described in detail in Grokking Bitcoin. You just need to know that they&amp;rsquo;re 256-bit numbers.
&lt;/center>
&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>This means that if an attacker knows the parent extended public key
(xpub), and a valid signature for a child key, then the attacker can
use this trick to forge signatures for the parent xpub, as well as any
child xpubs that can be derived from the parent xpub. This is a
problem not only for BIP32, but for many schemes using public key
addition somehow, for example, Taproot
(&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs">BIP341&lt;/a>). For
a bit more details, please visit
&lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#Design">the Design section of BIP340&lt;/a>.&lt;/p>
&lt;h2 id="next-steps">Next steps&lt;/h2>
&lt;p>In the next post, I&amp;rsquo;ll show how Schnorr signatures can be used in a
multisignature setting to produce a signature that looks just like a
normal single signature. This is very practical in Bitcoin because it
reduces resource requirements for verifying the blockchain.&lt;/p>
&lt;p>&lt;em>This is a cross-post from &lt;a href="https://popeller.io/schnorr-basics">my personal blog&lt;/a>.&lt;/em>&lt;/p></description></item><item><title>Compact Block Filters Deep Dive (BIP 158)</title><link>https://bitcoin-dev.blog/blog/bip158-deep-dive/</link><pubDate>Sat, 13 Nov 2021 09:32:00 +0200</pubDate><guid>https://bitcoin-dev.blog/blog/bip158-deep-dive/</guid><description>&lt;p>In this post, I will briefly describe the needs of a bitcoin light client and
why compact block filters satisfy these needs better than Bloom filters do. Then
I will dive into exactly how compact block filters work and will follow this
with a step-by-step guide for constructing such a filter from a testnet block.&lt;/p>
&lt;h4 id="the-purpose-of-block-filters">The purpose of block filters&lt;/h4>
&lt;p>A bitcoin light client is software that can back a bitcoin wallet without
storing the blockchain. This means that it needs to be able to broadcast
transactions to the network, but most importantly, it must be able to pick up
when there is a new transaction that is relevant to the wallet it is backing.
There are two ways a transaction becomes relevant to a wallet: either it is
sending money to the wallet (creating a new output to a wallet address), or it
is spending one of the UTXOs that the wallet owns.&lt;/p>
&lt;h4 id="what-was-wrong-with-bloom-filters">What was wrong with Bloom filters?&lt;/h4>
&lt;p>Before &lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki">BIP 158&lt;/a> came along, the most widely used method for light clients was
to use Bloom filters&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> as described in &lt;a href="https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki">BIP 37&lt;/a>. With a bloom
filter, you take all the objects you are interested in (script pub keys spent or
created), hash them a couple times and add the result of each to a bit map
called a Bloom filter. This filter represents what you are interested in. You
would then send this filter to a trusted bitcoin node and ask them to send you
anything that matches your filter. The problem with this is that it is not very
private since you are revealing some information to the bitcoin node you are
sending this filter to. They can start getting an idea of the transactions you
are interested in as well as the ones you are definitely not interested in. They
can also just decide not to send you a transaction that matches the filter. So
as you can see, it isn’t great for the light client. But it is also not great
for the bitcoin node serving the light client. Each time you send them a filter,
they have to load the relevant block from disk and determine which transactions
match your filter. You could just spam them with fake filters and effectively
DOS them. It takes very little energy to create a filter and lots to respond to
it.&lt;/p>
&lt;h4 id="introducing-compact-block-filters">Introducing Compact Block Filters:&lt;/h4>
&lt;p>Ok, take two. What we want is:&lt;/p>
&lt;ul>
&lt;li>More privacy&lt;/li>
&lt;li>Less asymmetry in the client - server work load. Ie, the server should be
required to do way less work.&lt;/li>
&lt;li>Less trust. The light client shouldn&amp;rsquo;t need to worry about the server holding
back relevant transactions.&lt;/li>
&lt;/ul>
&lt;p>With compact block filters, the server (full node) will for each block construct
a deterministic filter that includes all the objects in the block. This filter
can be calculated once and persisted. If light clients request a filter for a
block, there is no asymmetry since the server won&amp;rsquo;t have to do any more work
than the client had to do when making the request. A light client can also
choose to download the filters from multiple sources to ensure they match and
can always download the full block and check for itself if the filter that the
server provided was indeed correct given the block&amp;rsquo;s contents. Another bonus is
that this is way more private. The light client no longer sends a fingerprint of
the data it is interested in to the server. And so it becomes way more difficult
to analyse the light client&amp;rsquo;s activity. The light client gets these filters from
the server and checks for itself if any of its objects match what is seen in the
filter, and if it does match, then the light client asks for the full block. One
thing to note with this way of doing things is that full nodes serving the light
clients will need to persist these filters, and the light clients might also want
to persist a few filters and so it is important that the filters are as small as
possible (hence the name, compact block filters).&lt;/p>
&lt;p>Cool! Now we get to the cool stuff. How is this filter created? What does it
look like?&lt;/p>
&lt;p>What do we want?&lt;/p>
&lt;ul>
&lt;li>We want to put fingerprints of certain objects in the filter so that when
clients are looking to see if a block maybe contains info relevant to them,
they can take all their objects and check if the filter matches on those
objects.&lt;/li>
&lt;li>We want the filters to be as small as possible.&lt;/li>
&lt;li>Effectively we want to sort of summarise some of the block info… in a size
much much smaller than the block.&lt;/li>
&lt;/ul>
&lt;p>The info included in the basic filter is: every transaction&amp;rsquo;s input&amp;rsquo;s
scriptPubKey being spent and every transaction&amp;rsquo;s output&amp;rsquo;s scriptPubKey being
created. So something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">objects&lt;/span> = {&lt;span style="color:#a6e22e">spk1&lt;/span>, &lt;span style="color:#a6e22e">spk2&lt;/span>, &lt;span style="color:#a6e22e">spk3&lt;/span>, &lt;span style="color:#a6e22e">spk4&lt;/span>, &lt;span style="color:#f92672">...&lt;/span>, &lt;span style="color:#a6e22e">spkN&lt;/span>} &lt;span style="color:#75715e">// A list of N scriptPubKeys.
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Technically we could just stop here and say this list of scriptPubKeys is our
filter. It is a condensed version of what is in the blockchain and contains the
info the light client needs. With this list, they could tell with 100% certainty
if something they are interested in is in the block. But it is still pretty big.
So the next step is all about making this list as compact as possible. This is
where things get insanely cool.&lt;/p>
&lt;p>First, we convert each object into a number in a range such that the object
numbers are uniformly distributed in that range: Let&amp;rsquo;s say we have 10 objects (N
= 10), then we have some function that turns each of the objects into a number.
Let’s say we chose the range [0, 10] since we have 10 objects. Now the
hashing-plus-convert-to-number function we use will take each object and produce
a number in the space from [0, 10]. It is uniformly distributed in this space.
That means that, after ordering them, we will get (in the very, very ideal case)
something like this:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/compact-block-filters/dense.jpeg" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded" width="250" height="250"/>
&lt;/figure>
&lt;p>First of all, wow that is so great cause we have drastically decreased the size
of an objects fingerprint. Each one is just a number now. Ok so, let this be
our new filter:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">numbers&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> {&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>,&lt;span style="color:#ae81ff">7&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">9&lt;/span>,&lt;span style="color:#ae81ff">10&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now a light client downloads the filter and wants to see if one of the objects
they are looking for is matched in this filter. All they need to do is take
their objects and do the same hashing-plus-convert-to-number scheme and check if
any of the numbers are in the filter. What is the problem? The filter has a
number for each possible number in the space! Meaning that absolutely any object
will match on this filter. In other words, the false-positive rate of this
filter is 1. This is no good. We have lost too much info on our quest to
compress the data in the filter. What we need is a higher false-positive (fp)
rate. Ok so let’s say we want a false positive rate of 5. Then what we want is
to have our objects be mapped uniformly to a space of [0, 50]:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/compact-block-filters/sparse.png" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded" width="250" height="250"/>
&lt;/figure>
&lt;p>This is starting to look a bit better. If I am a client downloading this filter
and I check if my objects are maybe in the filter, there will be a 1/5 chance
that if it matches, it is a false positive. Great, so now we have mapped 10
objects to numbers between 0 &amp;amp; 50. This new list of numbers is our filter.
Again, we could stop here… but we can compress this even further!!&lt;/p>
&lt;p>We have this list of ordered numbers that we know are distributed uniformly
across this space between [0, 50]. We know that there are 10 items in the list.
What this means is that we can deduce that the most likely &lt;em>difference&lt;/em> between
each of the numbers in this ordered list is about 5. In general, if we have N
items and a false positive rate of M, then the space will be of size N * M. So
the numbers in the space can range from 0 to N * M, but the difference between
each number (once ordered) will be roughly M. M will definitely be a smaller
number to store than a number in the N * M space. So what we can do is instead
of storing each number, we can instead store the difference of each successive
number. In the above case, this would mean that instead of storing &lt;code>[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50]&lt;/code>, we just store &lt;code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5]&lt;/code>
and then it is trivial to reconstruct the original list. As you can gather,
storing the number 50 requires way more bits than storing the number 5. But why
stop there? We can compress this even further!&lt;/p>
&lt;p>This is where Golomb-Rice Coding comes in. This encoding works well for a list
of numbers that will all very likely be close to some number. This is what we
have! We have a list of numbers that will all very likely be close to 5 (or, in
general, close to our FP rate of M) and so taking the quotient of any number in
the list with that number (dividing each number by 5 and ignoring the remainder)
will very likely be 0 (if the number is slightly less than 5) or 1 if the number
is slightly more than 5. The quotient could be 2, 3, etc, but the likelihood
decreases a lot. Great! So we can take advantage of this knowledge and say that
we will encode a small quotient with the smallest number of bits that we can and
use more bits to encode larger, unlikely quotients. Then we also need to encode
the remainders (since we want to be able to reconstruct the values exactly), and
these will always be numbers between [0, M-1] (in our case, [0, 4]). For
encoding the quotients, we use the following mapping:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/compact-block-filters/quotient.png" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded" width="125" height="125"/>
&lt;/figure>
&lt;p>The mapping above is easy to read: The number of &lt;code>1&lt;/code>s indicates the quotient we
are encoding, and the &lt;code>0&lt;/code> indicates the end of the quotient encoding. So for each
number in our list, we encode the quotient using the above table, and then we
convert the remainder to binary using the number of bits needed to encode the
maximum of M-1. In our case, that is 3 bits. Here is a table showing the
encoding of the possible remainders in our example:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/compact-block-filters/remainder.png" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded" width="125" height="125"/>
&lt;/figure>
&lt;p>So, in our ideal case example, our list of &lt;code>[0, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]&lt;/code>
can be encoded as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#ae81ff">0000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Before we move on to a more realistic example, let’s see if we can reconstruct
our original list from this filter.&lt;/p>
&lt;p>Ok so we have: “0000100001000010000100001000010000100001000010000”. We know how
Golomb-Rice Coding encodes quotients and we also know that M is 5 (since this
will be public knowledge known to everyone using this filter construction).
Since we know M is 5, we know that 3 bits will be used to encode the remainders.
So we can take our filter and produce the following quotient-remainder tuples:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">[(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>), (&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>)]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We know that the quotients were produced by dividing the numbers by M (5), so we can
reconstruct these:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">[&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And we know that this list represents differences of numbers, so we can
reconstruct the OG list:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">[&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, &lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>, &lt;span style="color:#ae81ff">35&lt;/span>, &lt;span style="color:#ae81ff">40&lt;/span>, &lt;span style="color:#ae81ff">45&lt;/span>, &lt;span style="color:#ae81ff">50&lt;/span>]
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="a-more-realistic-example">A more realistic example&lt;/h4>
&lt;p>We will now try to construct a filter from an actual Bitcoin testnet block. I&amp;rsquo;m
going to use block &lt;a href="https://blockstream.info/testnet/block/000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c">2101914&lt;/a>. Let’s see what its actual filter is:&lt;/p>
&lt;pre tabindex="0">&lt;code>$ bitcoin-cli getblockhash 2101914
000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c
$ bitcoin-cli getblockfilter 000000000000002c06f9afaf2b2b066d4f814ff60cfbc4df55840975a00e035c
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#f92672">&amp;#34;filter&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270&amp;#34;&lt;/span>,
&lt;span style="color:#f92672">&amp;#34;header&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;8d0cd8353342930209ac7027be150e679bbc7c65cc62bb8392968e43a6ea3bfe&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok shweeeeeet, let’s see if we can reconstruct this filter from the block.&lt;/p>
&lt;p>The full code for this can be found in this &lt;a href="https://github.com/ellemouton/bip158Example">github repo&lt;/a>. I will just show some
pseudo code snippets here. The beef of the code is the function called
&lt;code>constructFilter&lt;/code>, which takes in a bitcoin client that can be used to make calls
to bitcoind and the block in question. The function looks something like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">constructFilter&lt;/span>(&lt;span style="color:#a6e22e">bc&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">bitcoind&lt;/span>.&lt;span style="color:#a6e22e">Bitcoind&lt;/span>, &lt;span style="color:#a6e22e">block&lt;/span> &lt;span style="color:#a6e22e">bitcoind&lt;/span>.&lt;span style="color:#a6e22e">Block&lt;/span>) ([]&lt;span style="color:#66d9ef">byte&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>) {
&lt;span style="color:#75715e">// 1. Collect all the objects from the block that we want to add to the filter
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// 2. Convert all the objects to numbers and sort them.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// 3. Get the differences between the sorted numbers
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">// 4. Encode these differences using Golomb-Rice Coding
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok so step 1 is to collect all the objects from the block that we want to add to
the filter. From the BIP, we know that these objects are all the scriptPubKeys
being spent as well as all the scriptPubKeys of each output. Some extra rules
from the BIP are that we skip the input for the coinbase transaction (since it
is empty and meaningless), and we skip any OP_RETURN outputs. We also
de-duplicate the data. So if there are two identical scriptPubKeys, we only
include one in the filter.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// The list of objects we want to include in our filter. These will be
&lt;/span>&lt;span style="color:#75715e">// every scriptPubKey being spent as well as each output&amp;#39;s scriptPubKey.
&lt;/span>&lt;span style="color:#75715e">// We use a map so that we can dedup any duplicate scriptPubKeys.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">objects&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make(&lt;span style="color:#66d9ef">map&lt;/span>[&lt;span style="color:#66d9ef">string&lt;/span>] &lt;span style="color:#66d9ef">struct&lt;/span>{})
&lt;span style="color:#75715e">// Loop over every transaction in the block.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">tx&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">block&lt;/span>.&lt;span style="color:#a6e22e">Tx&lt;/span> {
&lt;span style="color:#75715e">// Add the scriptPubKey of each of the transaction&amp;#39;s outputs
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// and add those to our list of objects.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">txOut&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">tx&lt;/span>.&lt;span style="color:#a6e22e">Vout&lt;/span> {
&lt;span style="color:#a6e22e">scriptPubKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">txOut&lt;/span>.&lt;span style="color:#a6e22e">ScriptPubKey&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">scriptPubKey&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#75715e">// We don&amp;#39;t add the output if it is an OP_RETURN (0x6a).
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">spk&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x6a&lt;/span> {
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#a6e22e">objects&lt;/span>[&lt;span style="color:#a6e22e">skpStr&lt;/span>] = &lt;span style="color:#66d9ef">struct&lt;/span>{}{}
}
&lt;span style="color:#75715e">// We don&amp;#39;t add the inputs of the coinbase transaction.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#75715e">// For each input, go and fetch the scriptPubKey that it is
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// spending.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">txIn&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">tx&lt;/span>.&lt;span style="color:#a6e22e">Vin&lt;/span> {
&lt;span style="color:#a6e22e">prevTx&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bc&lt;/span>.&lt;span style="color:#a6e22e">GetRawTransaction&lt;/span>(&lt;span style="color:#a6e22e">txIn&lt;/span>.&lt;span style="color:#a6e22e">Txid&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#a6e22e">scriptPubKey&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">prevTx&lt;/span>.&lt;span style="color:#a6e22e">Vout&lt;/span>[&lt;span style="color:#a6e22e">txIn&lt;/span>.&lt;span style="color:#a6e22e">Vout&lt;/span>].&lt;span style="color:#a6e22e">ScriptPubKey&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> len(&lt;span style="color:#a6e22e">scriptPubKey&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#a6e22e">objects&lt;/span>[&lt;span style="color:#a6e22e">spkStr&lt;/span>] = &lt;span style="color:#66d9ef">struct&lt;/span>{}{}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok great, we have all the objects we care about. And now we can also define the
variable N to be the length of the &lt;code>objects&lt;/code> map. In this example, N is 85.&lt;/p>
&lt;p>The next step is to convert each of the objects to numbers spread uniformly
across a range. Remember that this range depends on the false-positive rate we
want. BIP158 defines the constant M to be 784931. This means that we want every
1/784931 matches to be a false-positive. As we did in our earlier example, we
take this fp rate of M and multiply it by N to get the range that we want all
our numbers to lie in. We define this as F where F = M*N. In our case, we have
85 objects, and so F=66719135. I am not going to go into the details of the
function used to map our objects to numbers (you can check out the details of
this in the code in the linked repo). All you need to know for now is that it
takes in an object, the constant F, which defines the range that it needs to map
the object to, and a key which is the block hash. Once we have all the numbers,
we sort the list in ascending order, and then we also create a new list called
&lt;code>differences&lt;/code> which will hold the differences between each sequential number in
the sorted &lt;code>numbers&lt;/code> list.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">numbers&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">uint64&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">N&lt;/span>)
&lt;span style="color:#75715e">// Iterate over all the objects, convert them to numbers lying uniformly in the
&lt;/span>&lt;span style="color:#75715e">// range [0, F] and add them to the `numbers` list.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">o&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">objects&lt;/span> {
&lt;span style="color:#75715e">// Using the given key, max number (F) and object bytes (o),
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// convert the object to a number between 0 and F.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">convertToNumber&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>, &lt;span style="color:#a6e22e">F&lt;/span>, &lt;span style="color:#a6e22e">key&lt;/span>)
&lt;span style="color:#a6e22e">numbers&lt;/span> = append(&lt;span style="color:#a6e22e">numbers&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span>)
}
&lt;span style="color:#75715e">// Sort the numbers.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>.&lt;span style="color:#a6e22e">Slice&lt;/span>(&lt;span style="color:#a6e22e">numbers&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] &amp;lt; &lt;span style="color:#a6e22e">numbers&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>] })
&lt;span style="color:#75715e">// Convert the list of numbers to a list of differences.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">differences&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> make([]&lt;span style="color:#66d9ef">uint64&lt;/span>, &lt;span style="color:#a6e22e">N&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;span style="color:#a6e22e">differences&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">num&lt;/span>
&lt;span style="color:#66d9ef">continue&lt;/span>
}
&lt;span style="color:#a6e22e">differences&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>] = &lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">numbers&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Awesome! Here is a graph showing the values in the &lt;code>numbers&lt;/code> and &lt;code>differences&lt;/code>
lists:&lt;/p>
&lt;figure>&lt;img src="https://bitcoin-dev.blog/post-data/compact-block-filters/bitcoinExample.png" class="img img-fluid d-block mx-auto figure-center-img p-3 rounded" width="600" height="600"/>
&lt;/figure>
&lt;p>As you can see, the 85 numbers are really nicely uniformly distributed across
the space! And this results in the values in the &lt;code>differences&lt;/code> list being pretty
small.&lt;/p>
&lt;p>The last step now is to use Golomb-Rice Coding to encode this &lt;code>differences&lt;/code>
list. Recall from the earlier explanation that we need to divide each difference
by its most likely value and then we encode that quotient along with the
remainder. In my earlier example, I said that this most-likely value would be the
M that we choose and that the remainder would then lie in the range [0, M].
However, this is not what is done in the BIP as it was found&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> that
this is, in fact, not the ideal way to choose the Golomb-Rice coder parameter when
trying to optimize for the smallest possible size of the final encoded filter.
And so, instead of using M, a new constant of P is defined and P^2 is used as the
Golomb-Rice parameter. P is defined as 19. This means that each difference value
is divided by 2^19 to get the quotient and remainder and the remainder is then
encoded in binary in 19 bits.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">filter&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bstream&lt;/span>.&lt;span style="color:#a6e22e">NewBStreamWriter&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#75715e">// For each number in the differences list, calculate the quotient and
&lt;/span>&lt;span style="color:#75715e">// remainder after dividing by 2^P.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">differences&lt;/span> {
&lt;span style="color:#a6e22e">q&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">Floor&lt;/span>(float64(&lt;span style="color:#a6e22e">d&lt;/span>)&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">Exp2&lt;/span>(float64(&lt;span style="color:#a6e22e">P&lt;/span>)))
&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">d&lt;/span> &lt;span style="color:#f92672">-&lt;/span> uint64(&lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">Exp2&lt;/span>(float64(&lt;span style="color:#a6e22e">P&lt;/span>))&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">q&lt;/span>)
&lt;span style="color:#75715e">// Encode the quotient.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; int(&lt;span style="color:#a6e22e">q&lt;/span>); &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">WriteBit&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)
}
&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">WriteBit&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>)
&lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">WriteBits&lt;/span>(&lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">P&lt;/span>)
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Great stuff! Now when we print out this filter, we get:&lt;/p>
&lt;pre tabindex="0">&lt;code>71d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
&lt;/code>&lt;/pre>&lt;p>Apart from the first two bytes, this matches the filter we got from bitcoind
exactly! Why the 2 byte difference? The BIP says that the N value needs to be
encoded in CompactSize format and appended to the front of the filter so that it
can be decoded by the receiver. This is done as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">fd&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">filter&lt;/span>.&lt;span style="color:#a6e22e">Bytes&lt;/span>()
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">buffer&lt;/span> &lt;span style="color:#a6e22e">bytes&lt;/span>.&lt;span style="color:#a6e22e">Buffer&lt;/span>
&lt;span style="color:#a6e22e">buffer&lt;/span>.&lt;span style="color:#a6e22e">Grow&lt;/span>(&lt;span style="color:#a6e22e">wire&lt;/span>.&lt;span style="color:#a6e22e">VarIntSerializeSize&lt;/span>(uint64(&lt;span style="color:#a6e22e">N&lt;/span>)) &lt;span style="color:#f92672">+&lt;/span> len(&lt;span style="color:#a6e22e">fd&lt;/span>))
&lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">wire&lt;/span>.&lt;span style="color:#a6e22e">WriteVarInt&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">buffer&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, uint64(&lt;span style="color:#a6e22e">N&lt;/span>))
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">buffer&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">fd&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>If we print out the filter now, we get one that matches the one we got from
bitcoind exactly:&lt;/p>
&lt;pre tabindex="0">&lt;code>5571d126b85aa79c9de56d55995aa292de0484b830680a735793a8c2260113148421279906f800c3b8c94ff37681fb1fd230482518c52df57437864023833f2f801639692646ddcd7976ae4f2e2a1ef58c79b3aed6a705415255e362581692831374a5e5e70d5501cdc0a52095206a15cd2eb98ac980c22466e6945a65a5b0b0c5b32aa1e0cda2545da2c4345e049b614fcad80b9dc9c903788163822f4361bbb8755b79c276b1cf7952148de1e5ee0a92f6d70c4f522aa6877558f62b34b56ade12fa2e61023abf3e570937bf379722bc1b0dc06ffa1c5835bb651b9346a270
&lt;/code>&lt;/pre>&lt;p>Yay!&lt;/p>
&lt;p>However, from my understanding, there is no need to add N to the filter. If you
know the value of P, then you can figure out the value of N. Let’s do this now
by seeing if we can take the filter above, and reconstruct the original list of
numbers:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">bstream&lt;/span>.&lt;span style="color:#a6e22e">NewBStreamReader&lt;/span>(&lt;span style="color:#a6e22e">filter&lt;/span>)
&lt;span style="color:#66d9ef">var&lt;/span> (
&lt;span style="color:#a6e22e">numbers&lt;/span> []&lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;span style="color:#a6e22e">prevNum&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
)
&lt;span style="color:#66d9ef">for&lt;/span> {
&lt;span style="color:#75715e">// Read a quotient from the stream. Read until we encounter
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// a &amp;#39;0&amp;#39; bit indicating the end of the quotient. The number of
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// &amp;#39;1&amp;#39;s we encounter before reaching the &amp;#39;0&amp;#39; defines the
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// quotient.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">q&lt;/span> &lt;span style="color:#66d9ef">uint64&lt;/span>
&lt;span style="color:#a6e22e">c&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">ReadBit&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> {
&lt;span style="color:#a6e22e">q&lt;/span>&lt;span style="color:#f92672">++&lt;/span>
&lt;span style="color:#a6e22e">c&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> = &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">ReadBit&lt;/span>()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">Is&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">EOF&lt;/span>) {
&lt;span style="color:#66d9ef">break&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
}
}
&lt;span style="color:#75715e">// The following P bits are the remainder encoded as binary.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span>.&lt;span style="color:#a6e22e">ReadBits&lt;/span>(&lt;span style="color:#a6e22e">P&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">errors&lt;/span>.&lt;span style="color:#a6e22e">Is&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>, &lt;span style="color:#a6e22e">io&lt;/span>.&lt;span style="color:#a6e22e">EOF&lt;/span>) {
&lt;span style="color:#66d9ef">break&lt;/span>
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>
}
&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">q&lt;/span>&lt;span style="color:#f92672">*&lt;/span>uint64(&lt;span style="color:#a6e22e">math&lt;/span>.&lt;span style="color:#a6e22e">Exp2&lt;/span>(float64(&lt;span style="color:#a6e22e">P&lt;/span>))) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>
&lt;span style="color:#a6e22e">num&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">prevNum&lt;/span>
&lt;span style="color:#a6e22e">numbers&lt;/span> = append(&lt;span style="color:#a6e22e">numbers&lt;/span>, &lt;span style="color:#a6e22e">num&lt;/span>)
&lt;span style="color:#a6e22e">prevNum&lt;/span> = &lt;span style="color:#a6e22e">num&lt;/span>
}
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">numbers&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The above produces the same list of numbers that we had before and we were able
to reconstruct this without the knowledge of N. So I am not sure why it was
decided that N should be added to the filter. If anyone knows why it was
required to add N to the filter, please let me know!&lt;/p>
&lt;p>Cool, that was fun! Thanks for reading. This is a &lt;a href="https://www.ellemouton.com/blog/view/9">cross-post&lt;/a> from my
&lt;a href="https://www.ellemouton.com">website&lt;/a>, where you can find many more Bitcoin and Lightning related technical
posts. Until next time&amp;hellip; Yeeeeet!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Bloom_filter">https://en.wikipedia.org/wiki/Bloom_filter&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845">https://gist.github.com/sipa/576d5f09c3b86c3b1b75598d799fc845&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>Userspace, Statically Defined Tracing support for Bitcoin Core</title><link>https://bitcoin-dev.blog/blog/bitcoin-core-usdt-support/</link><pubDate>Mon, 30 Aug 2021 09:00:00 +0200</pubDate><guid>https://bitcoin-dev.blog/blog/bitcoin-core-usdt-support/</guid><description>&lt;p>&lt;em>This report updates on what 0xB10C, &lt;a href="https://blog.coinbase.com/announcing-our-first-bitcoin-core-developer-grants-3d88559db068">Coinbase Crypto Community Fund grant recipient&lt;/a>,
has been working on over the first half of his year-long Bitcoin development grant.
This specifically covers his work on Userspace, Statically Defined Tracing support
for Bitcoin Core. This report was published on &lt;a href="https://b10c.me/blog/008-bitcoin-core-usdt-support/">0xB10Cs blog&lt;/a> and the &lt;a href="https://blog.coinbase.com/userspace-statically-defined-tracing-support-for-bitcoin-core-e4076cd3e07">Coinbase blog&lt;/a> too.&lt;/em>&lt;/p>
&lt;p>The reference implementation to the Bitcoin protocol rules, Bitcoin Core, is
the most widely used software to interact with the Bitcoin network. Bitcoin
Core is, however, a black box to most users. While information can be queried
via the RPC interface or searched in the debug log, there is no defined interface
for real-time insights into process internals. Yet, some users could benefit
from more observability into their node. Hobbyists and companies running Bitcoin
Core in production want to include their nodes in their real-time monitoring.
Developers need visibility into test deployments to evaluate, review, debug,
and benchmark changes. Researchers want to observe and analyze the behavior
of nodes on the peer-to-peer network. Exchanges and other services handling
large sums of bitcoin want to detect attacks and other anomalies early.&lt;/p>
&lt;h3 id="peeking-inside-with-userspace-statically-defined-tracing">Peeking inside with Userspace, Statically Defined Tracing&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;p>The &lt;a href="https://ebpf.io">eBPF&lt;/a> technology present in the Linux kernel can be used for
observability into userspace applications. The technology allows
running a small, sandboxed program in the Linux kernel, which can hook
into predefined tracepoints in running processes. Once hooked into a
tracepoint, the program is executed each time the tracepoint is reached.
Tracepoints can pass data, for example, application state. Tracing scripts
can further process the data. The practice of hooking into tracepoints in
userspace applications is known as Userspace, Statically Defined Tracing
(USDT). For example, these tracepoints are also included in PostgreSQL,
MySQL, Python, NodeJS, Ruby, PHP, and libraries like libc, libpthread,
and libvirt.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>The static tracepoints can be leveraged by Bitcoin Core users wishing for
more insights into their node. Adding USDT support &lt;a href="https://github.com/bitcoin/bitcoin/pull/19866">did not require intrusive
changes&lt;/a>, and no custom tooling had to be written. When not used, the performance
impact of the tracepoints is minimal to non-existent. Only privileged processes
can hook into the tracepoints, no information leaks to other processes on the host.
These properties make Userspace, Statically Defined Tracing a good fit for Bitcoin
Core.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>For example, I &lt;a href="https://github.com/bitcoin/bitcoin/commit/4224dec22baa66547303840707cf1d4f15a49b20">placed two tracepoints&lt;/a> in the peer-to-peer message handling
code of Bitcoin Core. For each inbound and outbound P2P message, the tracepoints
pass information about the peer, the connection, and the message. This data can
be filtered and processed by tracing scripts. As a demo, I have built a P2P Monitor
that shows the communication between two peers in real-time. Users can find this
script alongside other &lt;a href="https://github.com/bitcoin/bitcoin/tree/master/contrib/tracing">USDT examples&lt;/a> in the &lt;code>contrib/tracing/&lt;/code> directory of the
Bitcoin Core repository.&lt;/p>
&lt;blockquote class="twitter-tweet" data-dnt="true">&lt;p lang="en" dir="ltr">Realtime Bitcoin Core P2P monitoring with User-Space, Statically Defined Tracing (USDT) and eBPF.&lt;br>&lt;br>This is one of the examples from &lt;a href="https://t.co/1QGb7jgsnZ">https://t.co/1QGb7jgsnZ&lt;/a> (with added IP masking). &lt;a href="https://t.co/E5mREYknEm">pic.twitter.com/E5mREYknEm&lt;/a>&lt;/p>&amp;mdash; b10c (@0xB10C) &lt;a href="https://twitter.com/0xB10C/status/1396889721859715077?ref_src=twsrc%5Etfw">May 24, 2021&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;h3 id="use-cases-for-userspace-statically-defined-tracing">Use-cases for Userspace, Statically Defined Tracing&lt;/h3>
&lt;p>I list some use-cases for Userspace, Statically Defined Tracing
I have thought about or worked on. With only three tracepoints merged,
there is plenty of room for developers to add new tracepoints and
get creative with tracing scripts. &lt;a href="https://github.com/bitcoin/bitcoin/issues/20981">Issue #20981&lt;/a> contains discussion
and ideas for additional tracepoints that can be implemented.&lt;/p>
&lt;p>Researchers and developers can use the P2P message tracepoints to
monitor P2P network anomalies in real-time. One example could be
detecting the recent &lt;code>addr&lt;/code> message flooding as reported in this
&lt;a href="https://bitcointalk.org/index.php?topic=5348856.0">bitcointalk.org post&lt;/a>. The messages were announcing random IP
addresses not belonging to nodes on the Bitcoin network. The flooding
has been &lt;a href="https://arxiv.org/abs/2108.00815">covered&lt;/a> in detail by Grundmann and Baumstark. They
discuss that the attacker could obtain the number of connected peers and
learn about other addresses, including Tor addresses, the node is listening
on. This would reduce the privacy of the node operator. It&amp;rsquo;s important to
stay vigilant to these attacks, discuss them, and then, if needed, react
to them.&lt;/p>
&lt;p>Similarly, I have been instrumenting the Bitcoin Core network address manager
with tracepoints. The addrman keeps track of gossiped network addresses for
potential outbound peers connections a node makes. It&amp;rsquo;s designed to be resiliant
against &lt;a href="https://cs-people.bu.edu/heilman/eclipse/">Eclipse Attacks&lt;/a>, where a node only has connections to peers controlled
by the attacker. The attacker can choose which information to feed to the node,
enabling, for example, double-spending attacks. Information about the addresses
in the addrman might help detect the build-up of an eclipse attack when combined
with other data.&lt;/p>
&lt;p>Additionally, these addrman tracepoints can be helpful during debugging and
code review. To showcase this, I build a tool that visualizes the addresses
in the addrman data structure based on the data submitted to the tracepoints.&lt;/p>
&lt;blockquote class="twitter-tweet" data-dnt="true">&lt;p lang="en" dir="ltr">Quiz: Which Bitcoin Core data-structure does this visualization show? &lt;a href="https://t.co/U6cnHBFWWT">pic.twitter.com/U6cnHBFWWT&lt;/a>&lt;/p>&amp;mdash; b10c (@0xB10C) &lt;a href="https://twitter.com/0xB10C/status/1407019872681332742?ref_src=twsrc%5Etfw">June 21, 2021&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;!-- raw HTML omitted -->
&lt;p>A Prometheus metric exporter can also build on top of the tracepoints
without requiring additional code in Bitcoin Core. There already exist
RPC-based Prometheus exporters and projects like &lt;a href="https://statoshi.info/">Statoshi&lt;/a>. However,
RPC-based exporters are limited by the information exposed via the RPC
interface, and Statoshi is large a patch-set that requires maintenance
on each Bitcoin Core release. I have published an experimental USDT-based
exporter called &lt;a href="https://github.com/0xb10c/bitcoind-observer">bitcoind-observer&lt;/a> that hooks into the three currently
merged tracepoints and serves metrics in the Prometheus format. The exporter
can be used by everyone currently running a Bitcoin Core node compiled with
USDT support. A demo is available on &lt;a href="https://bitcoind.observer">bitcoind.observer&lt;/a>. I&amp;rsquo;ve recently used
this to benchmark the bandwidth usage of &lt;a href="https://github.com/bitcoin/bitcoin/pull/21515">an implementation&lt;/a> of &lt;a href="https://arxiv.org/abs/1905.10518">Erlay:
Bandwidth-Efficient Transaction Relay for Bitcoin&lt;/a>. Initial results can be
found &lt;a href="https://github.com/naumenkogs/txrelaysim/issues/8#issuecomment-903255752">here&lt;/a>.&lt;/p>
&lt;p>The already existing tracepoint &lt;code>validation:block_connected&lt;/code> can be used
to benchmarking block validation. This allows, for example, to compare
the initial block download performance between different patches and can
aid in detecting performance improvements and regressions. For example,
the &lt;a href="https://github.com/chaincodelabs/bitcoinperf">bitcoinperf&lt;/a> project might benefit from such tracepoints. I&amp;rsquo;ve used
the tracepoint to &lt;a href="https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900662089">benchmark&lt;/a> Martin Ankerls pull request &lt;a href="https://github.com/bitcoin/bitcoin/pull/22702">#22702&lt;/a>. If
merged, the changes he proposes would result in a substantial block
validation speed up and reduction in memory usage.&lt;/p>
&lt;h3 id="next-steps">Next steps&lt;/h3>
&lt;p>I will collect further ideas for tracepoints and implement them alongside
example tracing scripts and more tooling. This will also involve
communicating with other Bitcoin and Bitcoin Core developers about
which tracepoints could be helpful in their projects. An example is
Antoine Riard&amp;rsquo;s &lt;a href="https://github.com/bitcoin/bitcoin/pull/18987">cross-layer anomaly detection watchdog&lt;/a> which he
initially proposed as a new, internal module to Bitcoin Core. However,
many of the required events and metrics can be collected by hooking into
tracepoints. This means the watchdog could be an external runtime, which
would speed up the watchdog development and requires less code and
maintenance on the Bitcoin Core side.&lt;/p>
&lt;p>If everything goes according to plan, the v23.0 release of Bitcoin Core,
expected in early 2022, will include the first set of tracepoints. A
goal is to enable USDT support in release builds by default, which still needs
some work. Additionally, the tracepoint API should be semi-stable and thus
needs testing.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>In short&lt;/strong>: I have been adding tracepoints to Bitcoin Core that users can hook
into to get insights into the internal state. The tracepoints are based on Linux
kernel technology and do not require intrusive changes or custom tooling. The
groundwork is done. Now further tracepoints can be added, and tooling can be written.&lt;/p></description></item></channel></rss>